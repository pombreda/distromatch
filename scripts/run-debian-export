#!/usr/bin/python

# distromatch - Match binary package names across distributions
#
# Copyright (C) 2011  Enrico Zini <enrico@enricozini.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Update all Debian distromatch sources

import sys
import os
import os.path
import re
import time
import logging
import psycopg2
import gzip

log = logging.getLogger(__name__)

class Binsrc(object):
    def __init__(self):
        self.db = psycopg2.connect(host="localhost",port=5441,user="guest",database="udd")

    def get(self, dist=None, release=None):
        """
        Generate (bin, src) couples with binary-source package mappings for the
        given distribution and release
        """
        c = self.db.cursor()

        if dist is None:
            c.execute("SELECT DISTINCT package, source FROM all_packages"
                      " ORDER BY package, source")
        elif release is None:
            c.execute("SELECT DISTINCT package, source FROM all_packages"
                      " WHERE distribution=%s"
                      " ORDER BY package, source", (dist,))
        else:
            c.execute("SELECT DISTINCT package, source FROM all_packages"
                      " WHERE distribution=%s and release=%s"
                      " ORDER BY package, source", (dist, release))

        for pkg, src in c:
            yield pkg, src


if __name__ == "__main__":
    from optparse import OptionParser

    VERSION="0.1"

    class Parser(OptionParser):
        def error(self, msg):
            sys.stderr.write("%s: error: %s\n\n" % (self.get_prog_name(), msg))
            self.print_help(sys.stderr)
            sys.exit(2)

    scriptdir = os.path.dirname(sys.argv[0])

    # FIXME: I hate messing with sys.path
    sys.path.append(os.path.abspath(os.path.join(scriptdir, "..")))
    import dmatch
    from dmatch import utils

    # Compute config defaults
    datadir = os.path.absname(os.path.join(scriptdir, "..", "data"))
    cachedir = os.path.absname(os.path.join(scriptdir, "..", "cache"))

    parser = Parser(usage="usage: %prog [options]",
                    version="%prog "+ VERSION,
                    description="Update all Debian distromatch sources")
    parser.add_option("-q", "--quiet", action="store_true",
                      help="quiet mode: only output warnings and errors")
    parser.add_option("--datadir", action="store", metavar="dir", default=datadir,
                      help="pathname to the data directory, where dist-* dirs are located"
                           " (default: %default)")
    parser.add_option("--cachedir", action="store", metavar="dir", default=cachedir,
                      help="pathname to the cache directory, intermediate results are stored"
                           " between update runs (default: %default)")
    (opts, args) = parser.parse_args()

    FORMAT = "%(asctime)-15s %(levelname)s %(message)s"
    if opts.quiet:
        logging.basicConfig(level=logging.WARNING, stream=sys.stderr, format=FORMAT)
    else:
        logging.basicConfig(level=logging.INFO, stream=sys.stderr, format=FORMAT)

    # TODO export CACHEDIR

    if not os.path.isdir(opts.cachedir):
        os.makedirs(opts.cachedir)

    # TODO touch -d "2 days ago" $CACHEDIR/rebuild-threshold
    now = time.time()

    binsrc = Binsrc()

    for d in os.listdir(opts.rootdir):
        mo = re.match(r"^dist-(debian|ubuntu)-(.+)", d)
        if not mo: continue
        dist = mo.group(1)
        release = mo.group(2)

        sourcedir = os.path.join(opts.rootdir, d)

        # Get the time this source was last updated
        fn_last_update = os.path.join(sourcedir, "last_update")
        if os.path.exists(fn_last_update):
            lastrun = os.path.getmtime(fn_last_update)
        else:
            lastrun = 0

        # Skip if it is quite up to date
        if now - lastrun < 86400 * 2:
            log.info("Skipping %s, which is only %.1fh old", d, (now - lastrun)/3600.0)
            continue

        # Generate bin<->src mapping
        with utils.atomic_writer(os.path.join(sourcedir, "binsrc.gz")) as fd:
            gzfd = gzip.GzipFile("binsrc", "w", fd)
            for bin, src in binsrc.get(dist, release):
                print >>gzfd, bin, src
            gzfd.close()

        # TODO FN_CONTENTFILES=$source/contentfiles
        # TODO FN_INTFILES=$source/interesting-files.gz

        # TODO # Generate interesting-files from Debian-style Content-* files
        # TODO if [ -f $FN_CONTENTFILES ]
        # TODO then
        # TODO     progress "Updating file lists in $source..."
        # TODO     if [ -x $FN_CONTENTFILES ]
        # TODO     then
        # TODO         $SCRIPTDIR/debian-mkfiles $($FN_CONTENTFILES) | gzip > $FN_INTFILES.tmp
        # TODO     else
        # TODO         $SCRIPTDIR/debian-mkfiles $(cat $FN_CONTENTFILES) | gzip > $FN_INTFILES.tmp
        # TODO     fi
        # TODO     mv $FN_INTFILES.tmp $FN_INTFILES
        # TODO fi

        # TODO name=$(basename $source)
        # TODO name=${name#dist-}


        # Touch the last_update file to indicate when we ran
        with open(fn_last_update, "w"):
            pass
